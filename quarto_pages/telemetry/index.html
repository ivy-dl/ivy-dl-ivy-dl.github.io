<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.361">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Telemetry Policy - Ivy</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../quarto_lib/lib/quarto-nav/quarto-nav.js"></script>
<script src="../quarto_lib/lib/clipboard/clipboard.min.js"></script>
<script src="../quarto_lib/lib/quarto-search/autocomplete.umd.js"></script>
<script src="../quarto_lib/lib/quarto-search/fuse.min.js"></script>
<script src="../quarto_lib/lib/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../img/logos/ivy_logo_only.png" rel="icon" type="image/png">
<script src="../quarto_lib/lib/quarto-html/quarto.js"></script>
<script src="../quarto_lib/lib/quarto-html/popper.min.js"></script>
<script src="../quarto_lib/lib/quarto-html/tippy.umd.min.js"></script>
<script src="../quarto_lib/lib/quarto-html/anchor.min.js"></script>
<link href="../quarto_lib/lib/quarto-html/tippy.css" rel="stylesheet">
<link href="../quarto_lib/lib/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../quarto_lib/lib/bootstrap/bootstrap.min.js"></script>
<link href="../quarto_lib/lib/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../quarto_lib/lib/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#telemetry-policy" id="toc-telemetry-policy" class="nav-link active" data-scroll-target="#telemetry-policy">Telemetry Policy</a>
  <ul class="collapse">
  <li><a href="#telemetry-modes" id="toc-telemetry-modes" class="nav-link" data-scroll-target="#telemetry-modes">Telemetry Modes</a></li>
  <li><a href="#setting-the-telemetry-mode" id="toc-setting-the-telemetry-mode" class="nav-link" data-scroll-target="#setting-the-telemetry-mode">Setting the Telemetry Mode</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">



<section id="telemetry-policy" class="level2">
<h2 class="anchored" data-anchor-id="telemetry-policy">Telemetry Policy</h2>
<p>We want to give Ivy‚Äôs users as much flexibility as possible when it comes to data collection. Therefore, there are <strong>five</strong> different data sharing modes for you to choose from. üòÑ</p>
<p>Keep in mind that any collected data is string-based and as concise as possible, this is, no training data, model parameter, or input array to your function or model will leave your computer at any time in terms of telemetry.</p>
<p>All of the data is totally anonymised, and is used to inform about Ivy‚Äôs usage, helping us prioritize the development of features and the improvement of the most used functions across all the versions of all the frameworks when it comes to compilation and transpilation.</p>
<p>Ivy will be a much better framework if it‚Äôs possible to prioritize adding new functions and improving existing ones based on their actual usage in the community, rather than leaving this all to guess work and potentially focusing our efforts on functions people don‚Äôt actually want or need.</p>
<p>More specifically, by sharing your data, this means more time will be spent on improving the functions, frameworks, and computation graphs that matter most for your projects.</p>
<p>If you use the premium features with an account, this data is stored in a database with the key being your account id. If you do not create an Ivy account, the data is stored in a database with the key being a securely hashed version of the IP address from where the call was made.</p>
<section id="telemetry-modes" class="level3">
<h3 class="anchored" data-anchor-id="telemetry-modes">Telemetry Modes</h3>
<p>This section outlines the different modes available to all users, as well as the data that is collected for each one when calling <code>ivy.compile</code>, <code>ivy.transpile</code>, or <code>ivy.unify</code>.</p>
<ol type="1">
<li><strong>stealth</strong></li>
</ol>
<p>No data at all. üòÑ</p>
<p>This mode is limited to users with the <strong>enterprise</strong> license only.</p>
<ol start="2" type="1">
<li><strong>api-calls</strong></li>
</ol>
<p>Ivy function signature and its timestamp.</p>
<p>As an example, the message produced by this function call would be:</p>
<pre><code>comp_fn = ivy.compile(fn, to=‚Äùtorch‚Äù, include_generators=True)

{
    "function": ivy.compile,
    "timestamp": 108586,
    "flags": {"to": "torch", "include_generators": "True"}
}</code></pre>
<p>This is helpful to understand the typical usage of Ivy, making it possible to focus the development on the more widely used features and use cases of Ivy.</p>
<ol start="3" type="1">
<li><strong>functional-api</strong></li>
</ol>
<p>Ivy function signature, timestamp, and the set of used functions from the corresponding functional API, without their frequencies.</p>
<p>A sample message in this case would be similar to:</p>
<pre><code>comp_fn = ivy.compile(fn, to=‚Äùtorch‚Äù, include_generators=True)

{
    "function": ivy.compile,
    "timestamp": 108586,
    "flags": {"to": "torch", "include_generators": "True"},
    "functions": ["torch.add", "torch.matmul"]
}</code></pre>
<p>As mentioned above, this helps prioritize the addition of new functions and fixing of existing ones based on actual user usage of them, rather than relying on guess work and potentially focusing our efforts on functions that may not be wanted or needed by the users.</p>
<ol start="4" type="1">
<li><strong>functional-api-frequency</strong></li>
</ol>
<p>Ivy function signature, timestamp, and the set of used functions from the corresponding functional API along the number of calls to each function.</p>
<p>A sample message if this mode is selected would be:</p>
<pre><code>comp_fn = ivy.compile(fn, to=‚Äùtorch‚Äù, include_generators=True)

{
    "function": ivy.compile,
    "timestamp": 108586,
    "flags": {"to": "torch", "include_generators": "True"},
    "functions": [["torch.add", 2], ["torch.matmul", 1]]
}</code></pre>
<p>Similar to the previous mode, this helps even more to prioritize certain functions that need to be included, fixed, or optimized based on their actual usage. The usage frequencies give another very helpful data point to be even more accurate with function prioritization, as it‚Äôs now possible to focus on the functions depending on how commonly used they are.</p>
<p><strong>NOTE:</strong> Users with the <strong>early pilot access</strong> should have this mode turned on at the minimum. This helps in informing the team about how Ivy is being used and where it can be improved. Thus, we ask for more usage data in order to improve our product at a faster pace.</p>
<ol start="5" type="1">
<li><strong>graph</strong></li>
</ol>
<p>Ivy function signature, timestamp and a text-based representation of the computation graph. This mode is set by <strong>default</strong> on <code>pip install ivy</code>.</p>
<p>If this mode is selected, telemetry messages will be similar to:</p>
<pre><code>comp_fn = ivy.compile(fn, to=‚Äùtorch‚Äù, include_generators=True)
{
    "function": ivy.compile,
    "timestamp": 108586,
    "flags": {"to": "torch", "include_generators": "True"},
    "graph": "&lt;graph_representation&gt;"
}</code></pre>
<p>where <code>&lt;graph_representation&gt;</code> would be a string containing:</p>
<pre><code>p708217 = args[0]
p862415 = args[1]
p817145 = torch.add(p708217, p862415)
p913484 = torch.add(p708217, p817145)
p868273 = torch.matmul(p913484, p817145)
return p868273</code></pre>
<p>In this case, telemetry helps not only with the function-level prioritization, but also with sub-function fixes and optimizations in Ivy‚Äôs functional API and Ivy‚Äôs frontends, as it‚Äôs now possible to distinguish which parameters or flags are used more often by users of the compiler and the transpiler.</p>
<p>Furthermore, having an anonymized, minimal version of the computational graph allows us to recreate and explore any error that arises during compilation or transpilation, which once again enables the prioritization of bug fixes and features based on real-world usage.</p>
<p>Below, you can find a summary of the modes and their corresponding data levels:</p>
<table class="table">
<colgroup>
<col style="width: 17%">
<col style="width: 10%">
<col style="width: 13%">
<col style="width: 19%">
<col style="width: 30%">
<col style="width: 8%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">stealth</th>
<th style="text-align: center;">api-calls</th>
<th style="text-align: center;">functional-api</th>
<th style="text-align: center;">functional-api-frequency</th>
<th style="text-align: center;">graph</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Ivy signature</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
</tr>
<tr class="even">
<td style="text-align: center;">Time stamp</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Functions</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
</tr>
<tr class="even">
<td style="text-align: center;">Frequency</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">x</td>
<td style="text-align: center;">x</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Graph repr.</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">x</td>
</tr>
</tbody>
</table>
</section>
<section id="setting-the-telemetry-mode" class="level3">
<h3 class="anchored" data-anchor-id="setting-the-telemetry-mode">Setting the Telemetry Mode</h3>
<p>By default, the telemetry mode is <code>graph</code>. To change this setting, you should modify the <code>config.json</code> file that you can find inside of your <code>.ivy</code> directory. More specifically, you will have to change the <code>data_level</code> field. For example, if you want to limit the telemetry to avoid sending the computational graph, you can modify <code>config.json</code> so that it looks like this:</p>
<pre><code>{
    "data_level": "functional-api-frequency"
}</code></pre>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>